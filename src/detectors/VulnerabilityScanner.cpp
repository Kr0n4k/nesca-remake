#include <VulnerabilityScanner.h>
#include <Connector.h>
#include <QRegularExpression>
#include <QTextStream>

QMap<QString, QList<Vulnerability>> VulnerabilityScanner::cveDatabase;

void VulnerabilityScanner::initializeCVEDatabase() {
    if (!cveDatabase.isEmpty()) return;
    
    // Hikvision vulnerabilities
    QList<Vulnerability> hikvisionVulns;
    
    Vulnerability cve202136260;
    cve202136260.cveId = "CVE-2021-36260";
    cve202136260.title = "Hikvision Command Injection";
    cve202136260.description = "Command injection vulnerability in Hikvision devices";
    cve202136260.severity = "Critical";
    cve202136260.cvssScore = 9.8f;
    cve202136260.affectedVersion = "< 5.6.0";
    cve202136260.references = QStringList() << "https://www.cve.org/CVERecord?id=CVE-2021-36260";
    hikvisionVulns.append(cve202136260);
    
    Vulnerability cve20177921;
    cve20177921.cveId = "CVE-2017-7921";
    cve20177921.title = "Hikvision Authentication Bypass";
    cve20177921.description = "Authentication bypass vulnerability in Hikvision devices";
    cve20177921.severity = "Critical";
    cve20177921.cvssScore = 9.8f;
    cve20177921.affectedVersion = "< 5.4.0";
    cve20177921.references = QStringList() << "https://www.cve.org/CVERecord?id=CVE-2017-7921";
    hikvisionVulns.append(cve20177921);
    
    cveDatabase["Hikvision"] = hikvisionVulns;
    
    // Dahua vulnerabilities
    QList<Vulnerability> dahuaVulns;
    
    Vulnerability cve202133045;
    cve202133045.cveId = "CVE-2021-33045";
    cve202133045.title = "Dahua Command Injection";
    cve202133045.description = "Command injection vulnerability in Dahua devices";
    cve202133045.severity = "Critical";
    cve202133045.cvssScore = 9.8f;
    cve202133045.affectedVersion = "< 2.000.0000006.0";
    cve202133045.references = QStringList() << "https://www.cve.org/CVERecord?id=CVE-2021-33045";
    dahuaVulns.append(cve202133045);
    
    cveDatabase["Dahua"] = dahuaVulns;
    
    // Zyxel vulnerabilities
    QList<Vulnerability> zyxelVulns;
    
    Vulnerability cve202230525;
    cve202230525.cveId = "CVE-2022-30525";
    cve202230525.title = "Zyxel Command Injection";
    cve202230525.description = "Command injection vulnerability in Zyxel devices";
    cve202230525.severity = "Critical";
    cve202230525.cvssScore = 9.8f;
    cve202230525.affectedVersion = "< 4.60";
    cve202230525.references = QStringList() << "https://www.cve.org/CVERecord?id=CVE-2022-30525";
    zyxelVulns.append(cve202230525);
    
    cveDatabase["Zyxel"] = zyxelVulns;
}

VulnerabilityScanner::VulnerabilityScanner() {
    initializeCVEDatabase();
}

VulnScanResult VulnerabilityScanner::scanDevice(const QString& ip, int port,
                                                const QString& deviceType,
                                                const QString& manufacturer,
                                                const QString& model,
                                                const QString& firmwareVersion) {
    VulnScanResult result;
    result.deviceIP = ip;
    result.devicePort = port;
    result.deviceType = deviceType;
    result.manufacturer = manufacturer;
    result.model = model;
    result.firmwareVersion = firmwareVersion;
    result.criticalCount = 0;
    result.highCount = 0;
    result.mediumCount = 0;
    result.lowCount = 0;
    
    initializeCVEDatabase();
    
    // Get vulnerabilities for this device
    QList<Vulnerability> vulns = getVulnerabilitiesForDevice(manufacturer, model, firmwareVersion);
    
    // Check each vulnerability
    for (Vulnerability& vuln : vulns) {
        vuln.confirmed = checkVulnerability(ip, port, vuln, deviceType, firmwareVersion);
        
        if (vuln.confirmed) {
            result.vulnerabilities.append(vuln);
            
            if (vuln.severity == "Critical") result.criticalCount++;
            else if (vuln.severity == "High") result.highCount++;
            else if (vuln.severity == "Medium") result.mediumCount++;
            else if (vuln.severity == "Low") result.lowCount++;
        }
    }
    
    return result;
}

QList<Vulnerability> VulnerabilityScanner::getVulnerabilitiesForDevice(
    const QString& manufacturer,
    const QString& model,
    const QString& firmwareVersion) {
    
    initializeCVEDatabase();
    
    if (!cveDatabase.contains(manufacturer)) {
        return QList<Vulnerability>();
    }
    
    QList<Vulnerability> allVulns = cveDatabase[manufacturer];
    QList<Vulnerability> relevantVulns;
    
    // Filter by version if provided
    for (const Vulnerability& vuln : allVulns) {
        if (firmwareVersion.isEmpty() || checkVersionPattern(firmwareVersion, vuln.affectedVersion)) {
            relevantVulns.append(vuln);
        }
    }
    
    return relevantVulns;
}

bool VulnerabilityScanner::hasCriticalVulnerabilities(const QString& manufacturer,
                                                      const QString& model,
                                                      const QString& firmwareVersion) {
    QList<Vulnerability> vulns = getVulnerabilitiesForDevice(manufacturer, model, firmwareVersion);
    
    for (const Vulnerability& vuln : vulns) {
        if (vuln.severity == "Critical") {
            return true;
        }
    }
    
    return false;
}

bool VulnerabilityScanner::checkVulnerability(const QString& ip, int port,
                                              const Vulnerability& vuln,
                                              const QString& deviceType,
                                              const QString& firmwareVersion) {
    // Specific checks for known CVEs
    if (vuln.cveId == "CVE-2021-36260") {
        return checkCVE_2021_36260(ip, port);
    } else if (vuln.cveId == "CVE-2021-33045") {
        return checkCVE_2021_33045(ip, port);
    } else if (vuln.cveId == "CVE-2017-7921") {
        return checkCVE_2017_7921(ip, port);
    } else if (vuln.cveId == "CVE-2022-30525") {
        return checkCVE_2022_30525(ip, port);
    }
    
    return false;
}

bool VulnerabilityScanner::checkPathExists(const QString& ip, int port, const QString& path) {
    std::string buffer;
    QString url;
    if (port == 443) {
        url = QString("https://%1:%2%3").arg(ip).arg(port).arg(path);
    } else {
        url = QString("http://%1:%2%3").arg(ip).arg(port).arg(path);
    }
    
    Connector conn;
    int result = conn.nConnect(url.toLocal8Bit().data(), port, &buffer);
    return (result >= 200 && result < 400);
}

QString VulnerabilityScanner::getResponseHeader(const QString& ip, int port, const QString& headerName) {
    std::string buffer;
    QString url;
    if (port == 443) {
        url = QString("https://%1:%2/").arg(ip).arg(port);
    } else {
        url = QString("http://%1:%2/").arg(ip).arg(port);
    }
    
    Connector conn;
    conn.nConnect(url.toLocal8Bit().data(), port, &buffer);
    
    QString response = QString::fromStdString(buffer);
    QRegularExpression regex(QString("%1:\\s*([^\\r\\n]+)").arg(headerName), QRegularExpression::CaseInsensitiveOption);
    QRegularExpressionMatch match = regex.match(response);
    
    if (match.hasMatch()) {
        return match.captured(1).trimmed();
    }
    
    return "";
}

bool VulnerabilityScanner::checkVersionPattern(const QString& version, const QString& pattern) {
    // Simplified version checking - in production should use proper version comparison
    return true;  // For now, assume vulnerable if firmware version is provided
}

bool VulnerabilityScanner::checkCVE_2021_36260(const QString& ip, int port) {
    // Check for Hikvision command injection vulnerability
    // This would attempt to detect the vulnerable endpoint
    return checkPathExists(ip, port, "/SDK/webLanguage") && 
           !checkPathExists(ip, port, "/ISAPI/Security/session/list");
}

bool VulnerabilityScanner::checkCVE_2021_33045(const QString& ip, int port) {
    // Check for Dahua command injection vulnerability
    return checkPathExists(ip, port, "/RPC2_Login") &&
           getResponseHeader(ip, port, "Server").contains("Dahua", Qt::CaseInsensitive);
}

bool VulnerabilityScanner::checkCVE_2017_7921(const QString& ip, int port) {
    // Check for Hikvision authentication bypass
    // Check if we can access device info without authentication
    QString response = "";
    std::string buffer;
    QString url = QString("http://%1:%2/ISAPI/Security/users/1").arg(ip).arg(port);
    Connector conn;
    int result = conn.nConnect(url.toLocal8Bit().data(), port, &buffer);
    return (result >= 200 && result < 300) && buffer.size() > 100;
}

bool VulnerabilityScanner::checkCVE_2022_30525(const QString& ip, int port) {
    // Check for Zyxel command injection
    return getResponseHeader(ip, port, "Server").contains("Zyxel", Qt::CaseInsensitive);
}

